<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pulse Monitor v2.7</title>
    
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pulse">

    <link rel="icon" id="dynamic-favicon">
    <link rel="apple-touch-icon" id="dynamic-apple-icon">
    <link rel="manifest" id="dynamic-manifest">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --slate-900: #0f172a;
            --slate-800: #1e293b;
            --slate-700: #334155;
            --slate-600: #475569;
            --slate-500: #64748b;
            --slate-400: #94a3b8;
            --slate-200: #e2e8f0;
            --sky-400: #38bdf8;
            --sky-500: #0ea5e9;
            --sky-600: #0284c7;
            --purple-500: #a855f7;
            --purple-600: #9333ea;
            --red-500: #ef4444;
            --amber-500: #f59e0b;
            --rose-500: #f43f5e;
        }
        body {
            background-color: var(--slate-900);
            color: var(--slate-200);
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            overflow: hidden; 
            touch-action: none; 
            -webkit-user-select: none;
            user-select: none;
        }
        canvas { 
            display: block; 
            width: 100%; 
            height: 100%; 
        }
        .pixelated { 
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: crisp-edges; 
        }
        .hidden-vid { 
            display: none; 
        }
        .scroller::-webkit-scrollbar { 
            width: 4px; 
        }
        .scroller::-webkit-scrollbar-track { 
            background: rgba(30, 41, 59, 0.3); 
        }
        .scroller::-webkit-scrollbar-thumb { 
            background: var(--slate-600); 
            border-radius: 2px; 
        }
        .control-panel {
            backdrop-filter: blur(12px);
            background-color: rgba(15, 23, 42, 0.92);
            padding-bottom: env(safe-area-inset-bottom);
        }
        input[type=range].scrubber {
            -webkit-appearance: none; 
            background: transparent;
        }
        input[type=range].scrubber::-webkit-slider-runnable-track {
            height: 6px; 
            background: var(--slate-700); 
            border-radius: 3px;
        }
        input[type=range].scrubber::-webkit-slider-thumb {
            -webkit-appearance: none; 
            height: 18px; 
            width: 18px;
            border-radius: 50%; 
            background: var(--sky-400); 
            margin-top: -6px;
            cursor: pointer; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .toggle-checkbox:checked { 
            right: 0; 
            border-color: var(--sky-400); 
        }
        .toggle-checkbox:checked + .toggle-label { 
            background-color: var(--sky-400); 
        }
        .tab-btn.active {
            background-color: var(--slate-700);
            color: var(--sky-400);
            border-bottom: 2px solid var(--sky-400);
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col">

    <div class="flex-none pt-safe-top px-4 pb-2 flex justify-between items-center bg-slate-900/80 border-b border-slate-700/50 z-10 backdrop-blur-md">
        <div class="flex flex-col pt-2">
            <span class="text-[10px] text-slate-400 uppercase tracking-widest font-bold">Heart Rate</span>
            <div class="flex items-baseline gap-2">
                <span id="bpmDisplay" class="text-4xl font-mono font-bold text-slate-500 tracking-tighter">--</span>
                <span id="modeBadge" class="hidden text-[10px] px-1.5 py-0.5 rounded bg-sky-900/50 border border-sky-700 text-sky-300 font-bold uppercase"></span>
            </div>
        </div>
        
        <div class="pt-2">
            <canvas id="previewCanvas" width="30" height="30" class="w-8 h-8 rounded border border-slate-600 bg-black hidden pixelated"></canvas>
        </div>
    </div>

    <div class="flex-grow relative bg-black overflow-hidden" id="canvasContainer">
        <canvas id="ppgCanvas"></canvas>
        <video id="videoElement" playsinline class="hidden-vid"></video>
        
        <div id="instructionOverlay" class="absolute inset-0 flex items-center justify-center pointer-events-none bg-black/60 z-10">
            <div class="text-center p-6 max-w-sm">
                <div class="text-slate-200 font-bold text-lg mb-2">Ready to Measure</div>
                <p class="text-slate-400 text-sm">Go to the Record tab to start.</p>
                <div class="mt-4 text-xs text-slate-500 border border-slate-700 rounded p-2 bg-slate-900/50">
                    <span class="font-bold text-sky-400">Camera Mode:</span> Cover the back camera & flash gently with your fingertip.
                </div>
            </div>
        </div>

        <div id="saturationWarning" class="hidden absolute top-4 left-0 right-0 text-center pointer-events-none">
            <span class="bg-rose-900/90 text-white text-[10px] font-bold px-3 py-1 rounded-full border border-rose-500 shadow-lg">⚠️ SIGNAL CLIPPING - Move finger slightly</span>
        </div>
        
        <div id="torchWarning" class="hidden absolute top-12 left-0 right-0 text-center pointer-events-none">
            <span class="bg-amber-900/90 text-white text-[10px] font-bold px-3 py-1 rounded-full border border-amber-500 shadow-lg">⚠️ Camera flash unavailable - Ensure good lighting</span>
        </div>

        <div class="absolute bottom-2 right-2 text-[9px] font-mono text-slate-600 pointer-events-none hidden sm:block">
            Gain: <span id="debugGain">1.0</span>x
        </div>

        <div id="reviewControls" class="absolute bottom-4 left-4 right-4 bg-slate-800/95 p-4 rounded-xl border border-slate-600/50 hidden flex-col gap-3 z-20 shadow-2xl backdrop-blur-xl">
            <div class="flex justify-between text-xs text-slate-300 font-bold">
                <span>Timeline</span>
                <span id="reviewTimeDisplay" class="font-mono text-sky-400">Live</span>
            </div>
            <input type="range" id="historySlider" min="0" max="100" value="100" class="w-full scrubber accent-sky-500">
            <div class="grid grid-cols-2 gap-3 mt-1">
                <button id="exportImgBtn" class="py-2.5 bg-slate-700 hover:bg-slate-600 text-white font-semibold rounded-lg text-xs border border-slate-600">
                    Save Graph Img
                </button>
                <button id="backToLiveBtn" class="py-2.5 bg-sky-600 hover:bg-sky-500 text-white font-semibold rounded-lg text-xs shadow-lg shadow-sky-900/20">
                    Done
                </button>
            </div>
        </div>
    </div>

    <!-- TABBED BOTTOM PANEL -->
    <div class="flex-none flex flex-col h-[45vh] min-h-[260px] control-panel border-t border-slate-700/50 z-20">
        <!-- Tab Navigation -->
        <div class="flex border-b border-slate-700/50 bg-slate-800/50">
            <button id="tabRecord" class="tab-btn active flex-1 py-3 text-sm font-bold text-slate-400 hover:text-white">
                Record
            </button>
            <button id="tabHistory" class="tab-btn flex-1 py-3 text-sm font-bold text-slate-400 hover:text-white">
                History
            </button>
            <button id="tabSettings" class="tab-btn flex-1 py-3 text-sm font-bold text-slate-400 hover:text-white">
                Settings
            </button>
        </div>

        <!-- Tab Content Container -->
        <div class="flex-grow overflow-hidden">
            
            <!-- RECORD TAB -->
            <div id="contentRecord" class="h-full flex flex-col p-4 gap-3">
                <div class="grid grid-cols-3 gap-2">
                    <button id="cameraBtn" class="h-12 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded-lg shadow-lg shadow-sky-900/20 text-xs">
                        Camera                    
                    </button>
                    <button id="simulateBtn" class="h-12 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg shadow-lg shadow-purple-900/20 text-xs">
                        Simulate
                    </button>
                    <button id="saveBtn" class="h-12 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-lg border border-slate-600 text-xs disabled:opacity-40" disabled>
                        Save
                    </button>
                </div>
                
                <div id="simControls" class="hidden bg-slate-800/80 p-2.5 rounded-lg border border-slate-700">
                    <div class="flex justify-between items-center mb-1">
                        <label class="text-[10px] font-bold text-purple-400 uppercase tracking-wider">Sim Rate</label>
                        <span id="targetBpmValue" class="text-[10px] font-mono bg-purple-900/50 text-purple-200 px-1.5 py-0.5 rounded">75</span>
                    </div>
                    <input type="range" id="bpmSlider" min="40" max="220" value="75" class="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-purple-500">
                </div>

                <div class="flex-grow flex items-center justify-center text-center p-4">
                    <div class="text-slate-500 text-sm">
                        <div class="mb-2">Select a recording mode above</div>
                        <div class="text-xs text-slate-600">
                            Camera for real measurements<br>
                            Simulate for testing
                        </div>
                    </div>
                </div>
            </div>

            <!-- HISTORY TAB -->
            <div id="contentHistory" class="hidden h-full flex flex-col">
                <div class="p-3 border-b border-slate-700/50 bg-slate-800/30">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-[10px] font-bold text-slate-400 uppercase tracking-wider">Storage</span>
                        <span id="storageInfo" class="text-[10px] font-mono text-slate-500">--</span>
                    </div>
                    <div class="w-full bg-slate-700 rounded-full h-2 overflow-hidden">
                        <div id="storageBar" class="bg-sky-500 h-full" style="width: 0%"></div>
                    </div>
                </div>

                <div class="px-3 py-2 bg-slate-800/50 text-[10px] font-bold text-slate-400 uppercase tracking-wider flex justify-between items-center">
                    <span id="recordCount">0 Recordings</span>
                    <div class="flex gap-2">
                        <button id="deleteOldestBtn" class="text-rose-400 hover:text-white p-1">
                            Del Oldest
                        </button>
                        <button id="exportJsonBtn" class="text-sky-400 hover:text-white p-1">
                            Export All ⬇
                        </button>
                    </div>
                </div>

                <div id="savedListContainer" class="flex-grow overflow-y-auto scroller p-2 space-y-1.5 pb-safe-bottom">
                    <div class="text-center text-slate-600 text-sm py-12" id="emptyState">
                        <div class="mb-2">No recordings yet</div>
                        <div class="text-xs text-slate-700">Start recording in the Record tab</div>
                    </div>
                </div>
            </div>

            <!-- SETTINGS TAB -->
            <div id="contentSettings" class="hidden h-full overflow-y-auto scroller p-4 space-y-4 pb-safe-bottom">
                <div class="flex items-center justify-between">
                    <label class="text-sm text-slate-300">Camera Preview</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none">
                        <input type="checkbox" id="settingPreview" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="settingPreview" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </div>

                <div class="flex items-center justify-between">
                    <label class="text-sm text-slate-300">
                        Auto-Stop (seconds)
                        <span class="block text-[10px] text-slate-500">0 = Manual stop</span>
                    </label>
                    <input type="number" id="settingAutoStop" min="0" max="300" class="w-16 bg-slate-900 border border-slate-600 rounded p-1 text-center text-sm text-white focus:border-sky-500 outline-none">
                </div>

                <div class="flex items-center justify-between">
                    <label class="text-sm text-slate-300">
                        BPM Averaging (Beats)
                        <span class="block text-[10px] text-slate-500">How many beats to average</span>
                    </label>
                    <input type="number" id="settingBpmWindow" min="2" max="50" class="w-16 bg-slate-900 border border-slate-600 rounded p-1 text-center text-sm text-white focus:border-sky-500 outline-none">
                </div>
                
                <div class="flex items-center justify-between">
                    <label class="text-sm text-slate-300">
                        Max Recordings
                        <span class="block text-[10px] text-slate-500">0 = No limit (until full)</span>
                    </label>
                    <input type="number" id="settingMaxRecords" min="0" max="1000" class="w-16 bg-slate-900 border border-slate-600 rounded p-1 text-center text-sm text-white focus:border-sky-500 outline-none">
                </div>

                <div class="flex items-center justify-between">
                    <label class="text-sm text-slate-300">Auto-Save on Stop</label>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none">
                        <input type="checkbox" id="settingAutoSave" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                        <label for="settingAutoSave" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </div>

                <div class="border-t border-slate-700 pt-3 mt-2">
                    <h4 class="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2">Camera Specs</h4>
                    <div id="cameraStats" class="grid grid-cols-2 gap-2 text-[10px] font-mono text-slate-400">
                        <div class="bg-slate-900 p-1.5 rounded">Res: <span id="statRes" class="text-slate-200">--</span></div>
                        <div class="bg-slate-900 p-1.5 rounded">FPS: <span id="statFps" class="text-slate-200">--</span></div>
                        <div class="bg-slate-900 p-1.5 rounded">Exp: <span id="statExp" class="text-slate-200">--</span></div>
                        <div class="bg-slate-900 p-1.5 rounded">ISO: <span id="statIso" class="text-slate-200">--</span></div>
                    </div>
                </div>

                <div class="text-center pt-2">
                    <span class="text-[10px] text-slate-600 font-mono">Pulse Monitor v2.7</span>
                </div>
            </div>

        </div>
    </div>

<script>
'use strict';

// ============================================================================
// CONSTANTS
// ============================================================================
const CONSTANTS = {
    VERSION: 4,
    
    SIGNAL: {
        WARMUP_FRAMES: 30,
        MAX_HISTORY_LENGTH: 10800,
        NORMALIZATION_WINDOW: 120,
        GAIN_SMOOTHING: 0.95,
        TARGET_GAIN_RANGE: 0.7,
        SIGNAL_CLAMP_MIN: -0.6,
        SIGNAL_CLAMP_MAX: 0.6,
        SATURATION_THRESHOLD: 250
    },
    
    BEAT_DETECTION: {
        MIN_GAP_SAMPLES: 15,
        MIN_AMPLITUDE: 0.15,
        DECAY_RATE: 0.99,
        THRESHOLD_MULTIPLIER: 0.5,
        BASE_THRESHOLD: 0.05,
        REFRACTORY_PERIOD_MS: 250,
        REFRACTORY_MIN_MS: 250,
        REFRACTORY_MAX_MS: 1000,
        REFRACTORY_FACTOR: 0.6
    },
    
    BPM: {
        DEFAULT_WINDOW: 8,
        SMOOTHING: 0.7,
        MS_PER_MINUTE: 60000
    },
    
    SIMULATION: {
        DEFAULT_BPM: 75,
        GAUSSIAN_P_WAVE: { amplitude: 0.3, center: 0.5, width: 0.12 },
        GAUSSIAN_QRS: { amplitude: 1.0, center: 0.2, width: 0.08 },
        NOISE_AMPLITUDE: 0.1,
        SIGNAL_SCALE: 0.05
    },
    
    STORAGE: {
        KEY: 'hr_records',
        SETTINGS_KEY: 'pulse_settings',
        QUOTA_CRITICAL: 0.95,
        MIN_SAVE_LENGTH: 60,
        DELETE_BATCH_SIZE: 10,
        MAX_STORAGE_MB: 5
    },
    
    UI: {
        GRID_MINOR_INTERVAL: 0.2,
        GRID_MAJOR_INTERVAL: 1.0
    },
    
    CAMERA: {
        IDEAL_WIDTH: 320,
        IDEAL_HEIGHT: 240,
        IDEAL_FPS: 60,
        MIN_FPS: 30,
        PREVIEW_SIZE: 30,
        EXPOSURE_COMPENSATION: -1.0
    }
};

// ============================================================================
// PWA Setup
// ============================================================================
(function() {
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'><rect width='512' height='512' fill='#0f172a'/><path d='M256 448l-30-30C118 322 48 250 48 162 48 90 106 32 178 32c40 0 78 22 96 56 18-34 56-56 96-56 72 0 130 58 130 130 0 88-70 160-178 256l-30 30z' fill='#ef4444'/></svg>`;
    const url = "data:image/svg+xml;base64," + btoa(svg);
    
    document.getElementById('dynamic-favicon').href = url;
    document.getElementById('dynamic-apple-icon').href = url;
    
    const manifest = {
        name: "Pulse Monitor",
        short_name: "Pulse",
        start_url: ".",
        display: "standalone",
        background_color: "#0f172a",
        theme_color: "#0f172a",
        orientation: "portrait",
        icons: [{src: url, sizes: "512x512", type: "image/svg+xml"}]
    };
    
    document.getElementById('dynamic-manifest').href = 
        "data:application/manifest+json;base64," + btoa(JSON.stringify(manifest));
})();

// ============================================================================
// SIGNAL PROCESSING MODULE
// ============================================================================
const SignalProcessor = {
    recentValues: [],
    currentGain: 1.0,
    signalMean: 0,
    framesSinceStart: 0,
    
    reset() {
        this.recentValues = [];
        this.currentGain = 1.0;
        this.signalMean = 0;
        this.framesSinceStart = 0;
    },
    
    normalize(val) {
        this.recentValues.push(val);
        if (this.recentValues.length > CONSTANTS.SIGNAL.NORMALIZATION_WINDOW) {
            this.recentValues.shift();
        }
        
        let min = -0.01, max = 0.01;
        for (let v of this.recentValues) {
            if (v < min) min = v;
            if (v > max) max = v;
        }
        
        const targetGain = CONSTANTS.SIGNAL.TARGET_GAIN_RANGE / ((max - min) || 0.1);
        this.currentGain = (this.currentGain * CONSTANTS.SIGNAL.GAIN_SMOOTHING) + 
                          (targetGain * (1 - CONSTANTS.SIGNAL.GAIN_SMOOTHING));
        
        const normalized = val * this.currentGain;
        return Math.max(CONSTANTS.SIGNAL.SIGNAL_CLAMP_MIN, 
                       Math.min(CONSTANTS.SIGNAL.SIGNAL_CLAMP_MAX, normalized));
    },
    
    processFrame(videoElement, offscreenContext) {
        const size = CONSTANTS.CAMERA.PREVIEW_SIZE;
        offscreenContext.drawImage(videoElement, 0, 0, size, size);
        const data = offscreenContext.getImageData(0, 0, size, size).data;
        
        let sum = 0, count = 0;
        for (let i = 0; i < data.length; i += 16) {
            sum += data[i + 1];
            count++;
        }
        
        const avg = sum / count;
        const isSaturated = avg > CONSTANTS.SIGNAL.SATURATION_THRESHOLD;
        
        if (this.framesSinceStart < CONSTANTS.SIGNAL.WARMUP_FRAMES) {
            this.signalMean = avg;
            this.framesSinceStart++;
            return { signal: 0, isSaturated };
        }
        
        this.signalMean = (this.signalMean * 0.95) + (avg * 0.05);
        return { signal: this.normalize(this.signalMean - avg), isSaturated };
    },
    
    generateSimulation(phase, bpm, totalTime) {
        const duration = 60 / bpm;
        const t = (phase % duration) / duration;
        
        const gaussian = (params) => {
            const { amplitude, center, width } = params;
            return amplitude * Math.exp(-Math.pow(t - center, 2) / (2 * width * width));
        };
        
        const signal = 
            gaussian(CONSTANTS.SIMULATION.GAUSSIAN_QRS) + 
            gaussian(CONSTANTS.SIMULATION.GAUSSIAN_P_WAVE) + 
            Math.sin(totalTime) * CONSTANTS.SIMULATION.NOISE_AMPLITUDE;
        
        return this.normalize(signal * CONSTANTS.SIMULATION.SIGNAL_SCALE);
    }
};

// ============================================================================
// BEAT DETECTION MODULE
// ============================================================================
const BeatDetector = {
    lastBeatTime: 0,
    refractoryPeriod: CONSTANTS.BEAT_DETECTION.REFRACTORY_PERIOD_MS,
    runningMax: 0.1,
    threshold: CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD,
    detectedBeats: [],
    bpm: 0,
    
    reset() {
        this.lastBeatTime = 0;
        this.refractoryPeriod = CONSTANTS.BEAT_DETECTION.REFRACTORY_PERIOD_MS;
        this.runningMax = 0.1;
        this.threshold = CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD;
        this.detectedBeats = [];
        this.bpm = 0;
    },
    
    process(signal, timestamp, bpmWindow) {
        this.runningMax *= CONSTANTS.BEAT_DETECTION.DECAY_RATE;
        this.threshold = Math.max(
            this.runningMax * CONSTANTS.BEAT_DETECTION.THRESHOLD_MULTIPLIER,
            CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD
        );
        
        if (signal > this.runningMax) this.runningMax = signal;
        
        let isBeat = false;
        
        if (signal > this.threshold && 
            (timestamp - this.lastBeatTime) > this.refractoryPeriod &&
            this.runningMax > CONSTANTS.BEAT_DETECTION.MIN_AMPLITUDE) {
            
            this.lastBeatTime = timestamp;
            isBeat = true;
            this.detectedBeats.push(timestamp);
            
            while(this.detectedBeats.length > bpmWindow) {
                this.detectedBeats.shift();
            }

            if (this.detectedBeats.length >= 2) {
                let sum = 0;
                for (let i = 1; i < this.detectedBeats.length; i++) {
                    sum += (this.detectedBeats[i] - this.detectedBeats[i-1]);
                }
                
                const avgInterval = sum / (this.detectedBeats.length - 1);
                const newBpm = CONSTANTS.BPM.MS_PER_MINUTE / avgInterval;
                
                this.bpm = this.bpm === 0 ? newBpm : 
                    (this.bpm * CONSTANTS.BPM.SMOOTHING + newBpm * (1 - CONSTANTS.BPM.SMOOTHING));
                
                this.refractoryPeriod = Math.max(
                    CONSTANTS.BEAT_DETECTION.REFRACTORY_MIN_MS,
                    Math.min(
                        (CONSTANTS.BPM.MS_PER_MINUTE / this.bpm) * CONSTANTS.BEAT_DETECTION.REFRACTORY_FACTOR,
                        CONSTANTS.BEAT_DETECTION.REFRACTORY_MAX_MS
                    )
                );
            }
        }
        
        return { isBeat, threshold: this.threshold, bpm: Math.round(this.bpm) };
    },
    
    calculateThreshold(samples) {
        let runningMax = 0.1;
        const results = [];
        
        samples.forEach(val => {
            runningMax *= CONSTANTS.BEAT_DETECTION.DECAY_RATE;
            if (val > runningMax) runningMax = val;
            
            const threshold = Math.max(
                runningMax * CONSTANTS.BEAT_DETECTION.THRESHOLD_MULTIPLIER,
                CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD
            );
            results.push({ threshold, runningMax });
        });
        
        return results;
    },
    
    detectBeats(samples, thresholds) {
        const beatIndices = [];
        let lastBeatIndex = -1000;
        
        samples.forEach((val, i) => {
            const { threshold, runningMax } = thresholds[i];
            
            if (val > threshold && 
                (i - lastBeatIndex) > CONSTANTS.BEAT_DETECTION.MIN_GAP_SAMPLES && 
                runningMax > CONSTANTS.BEAT_DETECTION.MIN_AMPLITUDE) {
                beatIndices.push(i);
                lastBeatIndex = i;
            }
        });
        
        return beatIndices;
    },
    
    calculateBPM(beatIndices, timestamps, windowSize) {
        if (beatIndices.length < 2 || !timestamps) return null;
        
        const recent = beatIndices.slice(-windowSize);
        if (recent.length < 2) return null;
        
        const timeSpan = timestamps[recent[recent.length - 1]] - timestamps[recent[0]];
        if (timeSpan <= 0) return null;
        
        return Math.round(60 * (recent.length - 1) / timeSpan);
    }
};

// ============================================================================
// STORAGE MODULE
// ============================================================================
const Storage = {
    async save(recording) {
        const records = this.loadAll();
        
        if (Config.maxRecords > 0 && records.length >= Config.maxRecords) {
            records.splice(Config.maxRecords - 1);
        }

        const existingIndex = records.findIndex(r => r.id === recording.id);
        if (existingIndex >= 0) {
            records[existingIndex] = recording;
        } else {
            records.unshift(recording);
        }

        localStorage.setItem(CONSTANTS.STORAGE.KEY, JSON.stringify(records));
    },
    
    loadAll() {
        const raw = localStorage.getItem(CONSTANTS.STORAGE.KEY);
        if (!raw) return [];
        
        try {
            const records = JSON.parse(raw);
            return records.filter(r => r.v === CONSTANTS.VERSION && Array.isArray(r.samples));
        } catch(e) {
            console.error('Failed to load records', e);
            return [];
        }
    },
    
    delete(id) {
        const records = this.loadAll();
        localStorage.setItem(CONSTANTS.STORAGE.KEY, 
            JSON.stringify(records.filter(r => r.id !== id)));
    },
    
    deleteOldest(count = CONSTANTS.STORAGE.DELETE_BATCH_SIZE) {
        const records = this.loadAll();
        if (records.length === 0) return 0;
        
        const toDelete = Math.min(count, records.length);
        records.splice(records.length - toDelete, toDelete);
        localStorage.setItem(CONSTANTS.STORAGE.KEY, JSON.stringify(records));
        return toDelete;
    },
    
    exportAll() {
        const raw = localStorage.getItem(CONSTANTS.STORAGE.KEY);
        if (!raw) return null;
        return URL.createObjectURL(new Blob([raw], { type: 'application/json' }));
    },
    
    async checkQuota() {
        if (!navigator.storage || !navigator.storage.estimate) return true;
        
        try {
            const estimate = await navigator.storage.estimate();
            if (estimate.quota > 0) {
                const usageRatio = estimate.usage / estimate.quota;
                if (usageRatio > CONSTANTS.STORAGE.QUOTA_CRITICAL) {
                    alert("Storage full. Delete old recordings to continue.");
                    return false;
                }
            }
        } catch(e) {
            console.warn('Quota check failed', e);
        }
        return true;
    },
    
    getStorageSize() {
        const records = this.loadAll();
        return new Blob([JSON.stringify(records)]).size;
    }
};

// ============================================================================
// CONFIG MODULE
// ============================================================================
const Config = {
    showPreview: false,
    autoStopSeconds: 0,
    bpmCalculationWindow: CONSTANTS.BPM.DEFAULT_WINDOW,
    autoSave: false,
    maxRecords: 50,
    
    load() {
        const saved = localStorage.getItem(CONSTANTS.STORAGE.SETTINGS_KEY);
        if (saved) {
            try {
                Object.assign(this, JSON.parse(saved));
            } catch(e) {
                console.error('Failed to load settings', e);
            }
        }
    },
    
    save() {
        const data = {
            showPreview: this.showPreview,
            autoStopSeconds: this.autoStopSeconds,
            bpmCalculationWindow: this.bpmCalculationWindow,
            autoSave: this.autoSave,
            maxRecords: this.maxRecords
        };
        localStorage.setItem(CONSTANTS.STORAGE.SETTINGS_KEY, JSON.stringify(data));
    }
};

// ============================================================================
// RENDERER MODULE
// ============================================================================
const Renderer = {
    drawSignal(canvas, ctx, data, mode, viewStart, viewEnd) {
        if (!data || !data.length) return;
        
        const viewData = data.slice(viewStart, viewEnd);
        if (!viewData.length) return;

        const cy = canvas.height / 2;
        const sy = canvas.height / 2.2;
        const my = v => cy - v * sy;

        this._drawGrid(ctx, canvas, viewData);
        this._drawThreshold(ctx, viewData, my);
        this._drawWaveform(ctx, canvas, viewData, my, 
            mode === 'simulate' ? '#a855f7' : (mode === 'review' ? '#f59e0b' : '#ef4444'));
        this._drawBeats(ctx, viewData, my);
    },
    
    _drawGrid(ctx, canvas, viewData) {
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.font = "9px monospace";

        for (let i = 0; i < viewData.length; i++) {
            const currentTime = viewData[i].time;
            const prevTime = i > 0 ? viewData[i - 1].time : currentTime;
            
            if (Math.floor(currentTime / CONSTANTS.UI.GRID_MINOR_INTERVAL) !== 
                Math.floor(prevTime / CONSTANTS.UI.GRID_MINOR_INTERVAL)) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }

            if (Math.floor(currentTime / CONSTANTS.UI.GRID_MAJOR_INTERVAL) !== 
                Math.floor(prevTime / CONSTANTS.UI.GRID_MAJOR_INTERVAL)) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255,255,255,0.3)';
                ctx.fillText(Math.floor(currentTime) + 's', i, canvas.height - 2);
            }
        }
    },
    
    _drawThreshold(ctx, viewData, yTransform) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(255,200,0,0.3)';
        ctx.setLineDash([4, 4]);
        viewData.forEach((d, i) => {
            if (i === 0) ctx.moveTo(i, yTransform(d.threshold));
            else ctx.lineTo(i, yTransform(d.threshold));
        });
        ctx.stroke();
        ctx.setLineDash([]);
    },
    
    _drawWaveform(ctx, canvas, viewData, yTransform, color) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        viewData.forEach((d, i) => {
            if (i === 0) ctx.moveTo(i, yTransform(d.val));
            else ctx.lineTo(i, yTransform(d.val));
        });
        ctx.stroke();

        ctx.lineTo(viewData.length - 1, canvas.height);
        ctx.lineTo(0, canvas.height);
        ctx.fillStyle = color + "20";
        ctx.fill();
    },
    
    _drawBeats(ctx, viewData, yTransform) {
        ctx.fillStyle = "#fff";
        viewData.forEach((d, i) => {
            if (d.beat) {
                ctx.beginPath();
                ctx.arc(i, yTransform(d.val), 3, 0, Math.PI * 2);
                ctx.fill();
            }
        });
    }
};

// ============================================================================
// CAMERA MODULE
// ============================================================================
const Camera = {
    stream: null,
    
    async start(videoElement) {
        const constraints = {
            audio: false,
            video: {
                facingMode: 'environment',
                width: { ideal: CONSTANTS.CAMERA.IDEAL_WIDTH },
                height: { ideal: CONSTANTS.CAMERA.IDEAL_HEIGHT },
                frameRate: { ideal: CONSTANTS.CAMERA.IDEAL_FPS, min: CONSTANTS.CAMERA.MIN_FPS }
            }
        };
        
        this.stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = this.stream;
        
        await new Promise(r => videoElement.onloadedmetadata = r);
        
        const track = this.stream.getVideoTracks()[0];
        const torchAvailable = await this._applyOptimizedConstraints(track);
        await videoElement.play();
        
        return { track, torchAvailable };
    },
    
    async _applyOptimizedConstraints(track) {
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        const advanced = [];
        const mainConstraints = {};

        if (caps.torch) advanced.push({ torch: true });
        if (caps.focusMode && caps.focusMode.includes('continuous')) {
            mainConstraints.focusMode = 'continuous';
        }
        if (caps.whiteBalanceMode && caps.whiteBalanceMode.includes('single-shot')) {
            mainConstraints.whiteBalanceMode = 'single-shot';
        }
        if (caps.exposureCompensation) {
            const minExp = caps.exposureCompensation.min || -2;
            const maxExp = caps.exposureCompensation.max || 2;
            mainConstraints.exposureCompensation = Math.max(minExp, 
                Math.min(maxExp, CONSTANTS.CAMERA.EXPOSURE_COMPENSATION));
        }
        if (caps.iso && caps.iso.min) mainConstraints.iso = caps.iso.min;
        if (caps.frameRate && caps.frameRate.max >= 55) {
            mainConstraints.frameRate = { ideal: CONSTANTS.CAMERA.IDEAL_FPS };
        }

        try {
            await track.applyConstraints({ advanced, ...mainConstraints });
            return true;
        } catch (e) {
            console.warn('Could not apply advanced constraints:', e);
            if (caps.torch) {
                try {
                    await track.applyConstraints({ advanced: [{ torch: true }] });
                    return true;
                } catch(err) {
                    console.error('Torch unavailable:', err);
                }
            }
            return false;
        }
    },
    
    getStats(track) {
        const s = track.getSettings();
        return {
            resolution: `${s.width}x${s.height}`,
            fps: s.frameRate ? s.frameRate.toFixed(1) : '--',
            exposure: s.exposureCompensation || s.exposureMode || '--',
            iso: s.iso || '--'
        };
    },
    
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(t => {
                try {
                    t.applyConstraints({ advanced: [{ torch: false }] });
                } catch(e) {}
                t.stop();
            });
            this.stream = null;
        }
    }
};

// ============================================================================
// WAKE LOCK MODULE
// ============================================================================
const WakeLock = {
    lock: null,
    
    async acquire() {
        if ('wakeLock' in navigator && !this.lock) {
            try {
                this.lock = await navigator.wakeLock.request('screen');
                this.lock.addEventListener('release', () => { this.lock = null; });
                return true;
            } catch (err) {
                console.warn('Wake Lock error', err);
            }
        }
        return false;
    },
    
    async release() {
        if (this.lock) {
            try { await this.lock.release(); } 
            catch(e) { console.warn('Wake Lock release error', e); }
            this.lock = null;
        }
    }
};

// ============================================================================
// APPLICATION STATE
// ============================================================================
const AppState = {
    mode: 'idle',
    lastTime: 0,
    totalTime: 0,
    history: [],
    reviewData: null,
    reviewOffset: 0,
    simPhase: 0,
    simBpm: CONSTANTS.SIMULATION.DEFAULT_BPM,
    sessionId: null,
    sessionStartTime: null,
    currentTab: 'record',
    
    reset() {
        this.history = [];
        this.totalTime = 0;
        this.reviewData = null;
        this.reviewOffset = 0;
        SignalProcessor.reset();
        BeatDetector.reset();
    },
    
    startSession() {
        this.sessionId = Date.now();
        this.sessionStartTime = new Date().toISOString();
    },
    
    addHistoryPoint(time, val, threshold, beat, bpm) {
        this.history.push({ time, val, threshold, beat, bpm });
        if (this.history.length > CONSTANTS.SIGNAL.MAX_HISTORY_LENGTH) {
            this.history.shift();
        }
    }
};

// ============================================================================
// DOM ELEMENTS
// ============================================================================
const $ = id => document.getElementById(id);

const DOM = {
    video: $('videoElement'),
    canvas: $('ppgCanvas'),
    preview: $('previewCanvas'),
    container: $('canvasContainer'),
    bpmDisplay: $('bpmDisplay'),
    modeBadge: $('modeBadge'),
    instructionOverlay: $('instructionOverlay'),
    saturationWarning: $('saturationWarning'),
    torchWarning: $('torchWarning'),
    cameraBtn: $('cameraBtn'),
    simulateBtn: $('simulateBtn'),
    simControls: $('simControls'),
    bpmSlider: $('bpmSlider'),
    targetBpmValue: $('targetBpmValue'),
    debugGain: $('debugGain'),
    saveBtn: $('saveBtn'),
    savedList: $('savedListContainer'),
    reviewControls: $('reviewControls'),
    historySlider: $('historySlider'),
    backToLiveBtn: $('backToLiveBtn'),
    reviewTimeDisplay: $('reviewTimeDisplay'),
    emptyState: $('emptyState'),
    storageInfo: $('storageInfo'),
    storageBar: $('storageBar'),
    recordCount: $('recordCount'),
    exportJsonBtn: $('exportJsonBtn'),
    exportImgBtn: $('exportImgBtn'),
    deleteOldestBtn: $('deleteOldestBtn'),
    settingPreview: $('settingPreview'),
    settingAutoStop: $('settingAutoStop'),
    settingAutoSave: $('settingAutoSave'),
    settingBpmWindow: $('settingBpmWindow'),
    settingMaxRecords: $('settingMaxRecords'),
    statRes: $('statRes'),
    statFps: $('statFps'),
    statExp: $('statExp'),
    statIso: $('statIso'),
    tabRecord: $('tabRecord'),
    tabHistory: $('tabHistory'),
    tabSettings: $('tabSettings'),
    contentRecord: $('contentRecord'),
    contentHistory: $('contentHistory'),
    contentSettings: $('contentSettings')
};

const ctx = DOM.canvas.getContext('2d');
const offCtx = DOM.preview.getContext('2d', { willReadFrequently: true });

let animationFrameId = null;

// ============================================================================
// UI HELPERS
// ============================================================================
const UI = {
    updateBPMDisplay(bpm, colorClass) {
        DOM.bpmDisplay.innerText = bpm;
        DOM.bpmDisplay.className = "text-4xl font-mono font-bold tracking-tighter " + colorClass;
    },
    
    updateStorageInfo() {
        const records = Storage.loadAll();
        const sizeMB = (Storage.getStorageSize() / 1024 / 1024).toFixed(2);
        const percentage = (parseFloat(sizeMB) / CONSTANTS.STORAGE.MAX_STORAGE_MB) * 100;
        
        DOM.storageInfo.innerText = `${sizeMB}MB / ${CONSTANTS.STORAGE.MAX_STORAGE_MB}MB`;
        DOM.storageBar.style.width = Math.min(percentage, 100) + '%';
        DOM.recordCount.innerText = `${records.length} Recording${records.length !== 1 ? 's' : ''}`;
        
        DOM.storageBar.className = percentage > 90 ? 'bg-rose-500 h-full' : 
            (percentage > 70 ? 'bg-amber-500 h-full' : 'bg-sky-500 h-full');
    },
    
    updateCameraStats(track) {
        const stats = Camera.getStats(track);
        DOM.statRes.innerText = stats.resolution;
        DOM.statFps.innerText = stats.fps;
        DOM.statExp.innerText = stats.exposure;
        DOM.statIso.innerText = stats.iso;
    },
    
    switchTab(tabName) {
        DOM.tabRecord.classList.remove('active');
        DOM.tabHistory.classList.remove('active');
        DOM.tabSettings.classList.remove('active');
        DOM.contentRecord.classList.add('hidden');
        DOM.contentHistory.classList.add('hidden');
        DOM.contentSettings.classList.add('hidden');
        
        if (tabName === 'record') {
            DOM.tabRecord.classList.add('active');
            DOM.contentRecord.classList.remove('hidden');
        } else if (tabName === 'history') {
            DOM.tabHistory.classList.add('active');
            DOM.contentHistory.classList.remove('hidden');
        } else if (tabName === 'settings') {
            DOM.tabSettings.classList.add('active');
            DOM.contentSettings.classList.remove('hidden');
        }
        
        AppState.currentTab = tabName;
    },
    
    updateButtonsForMode(mode) {
        if (mode === 'camera') {
            DOM.cameraBtn.innerText = 'STOP';
            DOM.cameraBtn.className = 'h-12 bg-rose-600 hover:bg-rose-500 text-white font-bold rounded-lg shadow-lg shadow-rose-900/20 text-xs';
            DOM.simulateBtn.innerText = 'Simulate';
            DOM.simulateBtn.className = 'h-12 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg shadow-lg shadow-purple-900/20 text-xs';
            DOM.modeBadge.innerText = 'CAMERA';
            DOM.modeBadge.classList.remove('hidden');
        } else if (mode === 'simulate') {
            DOM.simulateBtn.innerText = 'STOP';
            DOM.simulateBtn.className = 'h-12 bg-rose-600 hover:bg-rose-500 text-white font-bold rounded-lg shadow-lg shadow-rose-900/20 text-xs';
            DOM.cameraBtn.innerText = 'Camera';
            DOM.cameraBtn.className = 'h-12 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded-lg shadow-lg shadow-sky-900/20 text-xs';
            DOM.modeBadge.innerText = 'SIM';
            DOM.modeBadge.classList.remove('hidden');
        } else if (mode === 'review') {
            DOM.modeBadge.innerText = 'REVIEW';
            DOM.modeBadge.classList.remove('hidden');
        } else {
            DOM.cameraBtn.innerText = 'Camera';
            DOM.cameraBtn.className = 'h-12 bg-sky-600 hover:bg-sky-500 text-white font-bold rounded-lg shadow-lg shadow-sky-900/20 text-xs';
            DOM.simulateBtn.innerText = 'Simulate';
            DOM.simulateBtn.className = 'h-12 bg-purple-600 hover:bg-purple-500 text-white font-bold rounded-lg shadow-lg shadow-purple-900/20 text-xs';
            DOM.modeBadge.classList.add('hidden');
        }
    }
};

// ============================================================================
// CANVAS RESIZE
// ============================================================================
function resizeCanvas() {
    DOM.canvas.width = DOM.container.clientWidth;
    DOM.canvas.height = DOM.container.clientHeight;
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ============================================================================
// SETTINGS MANAGEMENT
// ============================================================================
function loadSettings() {
    Config.load();
    DOM.settingPreview.checked = Config.showPreview;
    DOM.settingAutoStop.value = Config.autoStopSeconds;
    DOM.settingAutoSave.checked = Config.autoSave;
    DOM.settingBpmWindow.value = Config.bpmCalculationWindow;
    DOM.settingMaxRecords.value = Config.maxRecords;
    DOM.preview.classList.toggle('hidden', !Config.showPreview);
}

function saveSettings() {
    Config.showPreview = DOM.settingPreview.checked;
    Config.autoStopSeconds = parseInt(DOM.settingAutoStop.value) || 0;
    Config.bpmCalculationWindow = parseInt(DOM.settingBpmWindow.value) || CONSTANTS.BPM.DEFAULT_WINDOW;
    Config.maxRecords = parseInt(DOM.settingMaxRecords.value) || 0;
    Config.autoSave = DOM.settingAutoSave.checked;
    
    Config.save();
    DOM.preview.classList.toggle('hidden', !Config.showPreview);
    BeatDetector.reset();
}

// ============================================================================
// MODE MANAGEMENT
// ============================================================================
async function setMode(newMode) {
    const prevMode = AppState.mode;
    
    // AUTO-SAVE CHECK FIRST
    if ((prevMode === 'camera' || prevMode === 'simulate') && newMode === 'idle') {
        if (Config.autoSave && AppState.history.length >= CONSTANTS.STORAGE.MIN_SAVE_LENGTH) {
            await saveRecording();
        }
    }
    
    // Cleanup previous mode
    if (prevMode === 'camera' && newMode !== 'camera') {
        Camera.stop();
        await WakeLock.release();
        DOM.video.pause();
        DOM.video.srcObject = null;
    }
    
    if (prevMode === 'review' && newMode !== 'review') {
        AppState.reviewData = null;
    }

    AppState.mode = newMode;
    AppState.reset();
    
    DOM.saturationWarning.classList.add('hidden');
    DOM.torchWarning.classList.add('hidden');
    DOM.instructionOverlay.classList.add('hidden');
    DOM.saveBtn.disabled = true;
    DOM.saveBtn.innerText = "Save";
    DOM.reviewControls.classList.remove('flex');
    DOM.reviewControls.classList.add('hidden');
    DOM.simControls.classList.add('hidden');
    
    DOM.bpmDisplay.className = "text-4xl font-mono font-bold text-slate-500 tracking-tighter";
    DOM.bpmDisplay.innerText = "--";
    offCtx.clearRect(0, 0, CONSTANTS.CAMERA.PREVIEW_SIZE, CONSTANTS.CAMERA.PREVIEW_SIZE);

    UI.updateButtonsForMode(newMode);

    if (newMode === 'idle') {
        DOM.instructionOverlay.classList.remove('hidden');
        
    } else if (newMode === 'camera') {
        DOM.saveBtn.disabled = false;
        AppState.startSession();
        
        try {
            const { track, torchAvailable } = await Camera.start(DOM.video);
            UI.updateCameraStats(track);
            DOM.torchWarning.classList.toggle('hidden', torchAvailable);
            await WakeLock.acquire();
        } catch(err) {
            alert("Camera unavailable or permission denied.");
            setMode('idle');
        }
        
    } else if (newMode === 'simulate') {
        DOM.simControls.classList.remove('hidden');
        DOM.saveBtn.disabled = false;
        AppState.startSession();
        await WakeLock.acquire();
        
    } else if (newMode === 'review') {
        DOM.reviewControls.classList.remove('hidden');
        DOM.reviewControls.classList.add('flex');
    }
}

// ============================================================================
// SAVE & EXPORT
// ============================================================================
async function saveRecording() {
    const historySnapshot = [...AppState.history];

    if (historySnapshot.length < CONSTANTS.STORAGE.MIN_SAVE_LENGTH) {
        if (!Config.autoSave) {
            alert("Too short to save (minimum 1 second)");
        }
        return;
    }

    if (!(await Storage.checkQuota())) return;
    
    try {
        const recording = {
            id: AppState.sessionId || Date.now(),
            v: CONSTANTS.VERSION,
            timestamp: AppState.sessionStartTime || new Date().toISOString(),
            avgBpm: Math.round(BeatDetector.bpm) || '--',
            duration: AppState.totalTime,
            samples: historySnapshot.map(h => ({ t: h.time, v: h.val }))
        };

        await Storage.save(recording);
        renderRecordingsList();
        
        DOM.saveBtn.innerText = "Saved";
        setTimeout(() => DOM.saveBtn.innerText = "Save", 1500);
        
    } catch(e) {
        console.error(e);
        if (e.name === 'QuotaExceededError') {
            alert("Storage full. Please delete old recordings.");
        } else if (!Config.autoSave) {
            alert("Save failed");
        }
    }
}

function exportAllData() {
    const url = Storage.exportAll();
    if (!url) return alert("No data to export");
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `heart_rate_data_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function exportGraphImage() {
    const data = AppState.mode === 'review' ? AppState.reviewData : AppState.history;
    const viewEnd = AppState.mode === 'review' ? AppState.reviewOffset : data.length;
    
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, DOM.canvas.width, DOM.canvas.height);
    Renderer.drawSignal(DOM.canvas, ctx, data, AppState.mode, 0, viewEnd);
    
    ctx.save();
    ctx.fillStyle = "#0f172a";
    ctx.fillRect(0, 0, 140, 60);
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 24px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`${DOM.bpmDisplay.innerText} BPM`, 10, 30);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px sans-serif';
    ctx.fillText(new Date().toLocaleDateString(), 10, 45);
    ctx.restore();

    const link = document.createElement('a');
    link.download = `pulse_${Date.now()}.png`;
    link.href = DOM.canvas.toDataURL('image/png');
    link.click();
}

// ============================================================================
// RECORDINGS LIST
// ============================================================================
function renderRecordingsList() {
    const records = Storage.loadAll();
    UI.updateStorageInfo();
    DOM.savedList.innerHTML = '';
    
    if (!records.length) {
        return DOM.savedList.appendChild(DOM.emptyState);
    }
    
    records.forEach(r => {
        const d = new Date(r.timestamp);
        const div = document.createElement('div');
        
        div.className = "bg-slate-800/80 p-3 rounded-lg border border-slate-700 hover:border-sky-500 cursor-pointer flex justify-between items-center";
        
        div.innerHTML = `
            <div>
                <div class="font-bold text-sky-400 text-xs">
                    ${d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                </div>
                <div class="text-[10px] text-slate-500">
                    ${d.toLocaleDateString()} • ${r.duration.toFixed(1)}s
                </div>
            </div>
            <div class="flex items-center gap-3">
                <div class="text-right">
                    <div class="text-[9px] text-slate-500 uppercase">Avg BPM</div>
                    <div class="font-bold text-slate-200 text-sm">${r.avgBpm}</div>
                </div>
                <button class="del p-2 text-slate-500 hover:text-rose-400" data-id="${r.id}">✕</button>
            </div>
        `;
        
        div.onclick = (e) => {
            if (e.target.classList.contains('del')) {
                if (confirm('Delete this recording?')) {
                    Storage.delete(r.id);
                    renderRecordingsList();
                }
            } else {
                openReview(r);
            }
        };
        
        DOM.savedList.appendChild(div);
    });
}

function openReview(recording) {
    setMode('review');
    
    const values = recording.samples.map(s => s.v);
    const timestamps = recording.samples.map(s => s.t);
    
    const thresholds = BeatDetector.calculateThreshold(values);
    const beatIndices = BeatDetector.detectBeats(values, thresholds);
    const calculatedBpm = BeatDetector.calculateBPM(beatIndices, timestamps, Config.bpmCalculationWindow);

    AppState.reviewData = recording.samples.map((sample, i) => ({
        time: sample.t,
        val: sample.v,
        threshold: thresholds[i].threshold,
        beat: beatIndices.includes(i),
        bpm: calculatedBpm || recording.avgBpm
    }));
    
    AppState.reviewData.duration = recording.duration;
    
    DOM.historySlider.min = 0;
    DOM.historySlider.max = recording.samples.length;
    DOM.historySlider.value = recording.samples.length;
    AppState.reviewOffset = recording.samples.length;
    
    UI.updateBPMDisplay(calculatedBpm || recording.avgBpm, "text-amber-500");
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================
async function loop(timestamp) {
    if (!AppState.lastTime) AppState.lastTime = timestamp;
    
    const dt = (timestamp - AppState.lastTime) / 1000;
    AppState.lastTime = timestamp;

    if (AppState.mode === 'camera' || AppState.mode === 'simulate') {
        AppState.totalTime += dt;
        
        if (Config.autoStopSeconds > 0 && AppState.totalTime >= Config.autoStopSeconds) {
            await setMode('idle');
        } else {
            let signal, isSaturated;
            
            if (AppState.mode === 'camera') {
                const result = SignalProcessor.processFrame(DOM.video, offCtx);
                signal = result.signal;
                isSaturated = result.isSaturated;
                DOM.saturationWarning.classList.toggle('hidden', !isSaturated);
            } else {
                AppState.simPhase += dt;
                signal = SignalProcessor.generateSimulation(AppState.simPhase, AppState.simBpm, AppState.totalTime);
            }
            
            const result = BeatDetector.process(signal, timestamp, Config.bpmCalculationWindow);
            
            if (result.bpm > 0) {
                const colorClass = AppState.mode === 'camera' ? "text-green-500" : "text-purple-500";
                UI.updateBPMDisplay(result.bpm, colorClass);
            }
            
            DOM.debugGain.innerText = SignalProcessor.currentGain.toFixed(1);
            AppState.addHistoryPoint(AppState.totalTime, signal, result.threshold, result.isBeat, result.bpm);
        }
    }
    
    // Draw
    const data = AppState.mode === 'review' ? AppState.reviewData : AppState.history;
    if (data && data.length > 0) {
        const end = AppState.mode === 'review' ? AppState.reviewOffset : data.length;
        const start = Math.max(0, end - DOM.canvas.width);
        
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, DOM.canvas.width, DOM.canvas.height);
        Renderer.drawSignal(DOM.canvas, ctx, data, AppState.mode, start, end);
        
        if (AppState.mode === 'review' && end > 0 && data[end - 1]) {
            const currentTime = data[end - 1].time;
            const totalTime = data[data.length - 1].time;
            DOM.reviewTimeDisplay.innerText = `-${(totalTime - currentTime).toFixed(1)}s`;
            
            const values = data.slice(0, end).map(d => d.val);
            const timestamps = data.slice(0, end).map(d => d.time);
            const thresholds = BeatDetector.calculateThreshold(values);
            const beatIndices = BeatDetector.detectBeats(values, thresholds);
            const displayBpm = BeatDetector.calculateBPM(beatIndices, timestamps, Config.bpmCalculationWindow);
            
            if (displayBpm) UI.updateBPMDisplay(displayBpm, "text-amber-500");
        }
    }
    
    animationFrameId = requestAnimationFrame(loop);
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================
DOM.tabRecord.onclick = () => UI.switchTab('record');
DOM.tabHistory.onclick = () => UI.switchTab('history');
DOM.tabSettings.onclick = () => UI.switchTab('settings');

DOM.historySlider.oninput = e => AppState.reviewOffset = parseInt(e.target.value);
DOM.bpmSlider.oninput = e => {
    AppState.simBpm = parseInt(e.target.value);
    DOM.targetBpmValue.innerText = AppState.simBpm;
};

DOM.cameraBtn.onclick = () => setMode(AppState.mode === 'camera' ? 'idle' : 'camera');
DOM.simulateBtn.onclick = () => setMode(AppState.mode === 'simulate' ? 'idle' : 'simulate');
DOM.saveBtn.onclick = saveRecording;
DOM.backToLiveBtn.onclick = () => setMode('idle');
DOM.exportImgBtn.onclick = exportGraphImage;
DOM.exportJsonBtn.onclick = exportAllData;

DOM.deleteOldestBtn.onclick = () => {
    const records = Storage.loadAll();
    if (records.length === 0) return alert("No records to delete");
    
    const toDelete = Math.min(CONSTANTS.STORAGE.DELETE_BATCH_SIZE, records.length);
    if (confirm(`Delete oldest ${toDelete} recording${toDelete > 1 ? 's' : ''}?`)) {
        Storage.deleteOldest();
        renderRecordingsList();
    }
};

DOM.settingPreview.onchange = saveSettings;
DOM.settingAutoStop.onchange = saveSettings;
DOM.settingAutoSave.onchange = saveSettings;
DOM.settingBpmWindow.onchange = saveSettings;
DOM.settingMaxRecords.onchange = saveSettings;

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        cancelAnimationFrame(animationFrameId);
        if (AppState.mode === 'camera') {
            Camera.stop();
            WakeLock.release();
            AppState.mode = 'idle';
            DOM.modeBadge.innerText = "PAUSED";
            DOM.saveBtn.disabled = false;
            DOM.saveBtn.innerText = "Save Partial";
            UI.updateButtonsForMode('idle');
        }
    } else {
        loop(performance.now());
    }
});

window.onpagehide = () => {
    Camera.stop();
    WakeLock.release();
};

// ============================================================================
// INITIALIZATION
// ============================================================================
loadSettings();
renderRecordingsList();
UI.switchTab('record');
loop(performance.now());

</script>
</body>
</html>
