<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Pulse Monitor v2.7</title>
    
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pulse">

    <link rel="icon" id="dynamic-favicon">
    <link rel="apple-touch-icon" id="dynamic-apple-icon">
    <link rel="manifest" id="dynamic-manifest">

    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-medium: #1e293b;
            --bg-light: #334155;
            --text-color: #e2e8f0;
            --text-muted: #94a3b8;
            --primary: #0ea5e9;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
        }
        
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--bg-dark);
            color: var(--text-color);
            font-family: system-ui, -apple-system, sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }
        
        header {
            padding: 8px 16px;
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid #334155;
            backdrop-filter: blur(12px);
        }
        
        #canvasContainer {
            flex: 1;
            position: relative;
            background: black;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .canvas-preview {
            width: 32px;
            height: 32px;
            border: 1px solid #475569;
            background: black;
            image-rendering: pixelated;
        }
        
        video {
            display: none;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #334155;
            background: rgba(30, 41, 59, 0.5);
        }
        
        .tab {
            flex: 1;
            padding: 12px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
        }
        
        .tab.active {
            background: var(--bg-light);
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }
        
        .tab-content {
            display: none;
            padding: 16px;
            overflow-y: auto;
            height: calc(45vh - 48px);
            min-height: 212px;
        }
        
        .tab-content:not(.hidden) {
            display: block;
        }
        
        .storage-bar {
            height: 100%;
            background: #0ea5e9;
            transition: width 0.3s;
        }
        
        .storage-bar.warning {
            background: #f59e0b;
        }
        
        .storage-bar.critical {
            background: #ef4444;
        }
        
        .controls {
            height: 45vh;
            min-height: 260px;
            background: rgba(15, 23, 42, 0.92);
            border-top: 1px solid #334155;
            backdrop-filter: blur(12px);
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        
        button {
            padding: 12px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
        }
        
        #cameraBtn { background: #0ea5e9; color: white; }
        #simulateBtn { background: #a855f7; color: white; }
        #saveBtn { background: #10b981; color: white; }
        .btn-danger { background: #ef4444; color: white; }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
        }
        
        input[type="range"].scrubber {
            appearance: none;
            background: transparent;
            height: 20px;
        }
        
        input[type="range"].scrubber::-webkit-slider-runnable-track {
            height: 6px;
            background: #334155;
            border-radius: 3px;
        }
        
        input[type="range"].scrubber::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #38bdf8;
            margin-top: -6px;
            cursor: pointer;
        }
        
        .recordings {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .recording-item {
            padding: 12px;
            background: var(--bg-medium);
            border: 1px solid var(--bg-light);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .recording-item:hover {
            background: var(--bg-light);
        }
        
        .delete-btn {
            padding: 4px 8px;
            background: none;
            color: #64748b;
            border: none;
            cursor: pointer;
            font-size: 18px;
        }
        
        .delete-btn:hover {
            color: var(--danger);
        }
        
        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            pointer-events: none;
        }
        
        .review-controls {
            display: none;
            position: absolute;
            bottom: 16px;
            left: 16px;
            right: 16px;
            padding: 16px;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid #475569;
            border-radius: 8px;
            backdrop-filter: blur(12px);
        }
        
        .review-controls.active {
            display: block;
        }
        
        .hidden { display: none; }
        
        .warning {
            position: absolute;
            top: 16px;
            left: 0;
            right: 0;
            text-align: center;
            pointer-events: none;
        }
        
        .warning span {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(127, 29, 29, 0.9);
            color: white;
            font-size: 10px;
            font-weight: bold;
            border: 1px solid var(--danger);
            border-radius: 12px;
        }
        
        .scroller::-webkit-scrollbar {
            width: 4px;
        }
        
        .scroller::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
        }
        
        .scroller::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 2px;
        }
        
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
        }
        
        .setting-row input[type="number"] {
            width: 64px;
            padding: 4px;
            background: var(--bg-dark);
            border: 1px solid var(--bg-light);
            border-radius: 4px;
            color: var(--text-color);
            text-align: center;
        }
        
        small {
            display: block;
            font-size: 10px;
            color: #64748b;
        }
        
        .camera-stats {
            border-top: 1px solid var(--bg-light);
            padding-top: 12px;
            margin-top: 12px;
        }
        
        .camera-stats h4 {
            font-size: 10px;
            font-weight: bold;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }
        
        .camera-stats > div {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-family: monospace;
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .camera-stats > div > div {
            background: var(--bg-dark);
            padding: 6px;
            border-radius: 4px;
        }
        
        .camera-stats span {
            color: var(--text-color);
        }
        
        .version {
            text-align: center;
            padding-top: 12px;
            font-family: monospace;
            font-size: 10px;
            color: #475569;
        }
        
        
        .toggle-checkbox {
            position: relative;
            width: 40px;
            height: 20px;
            appearance: none;
            background: #475569;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .toggle-checkbox:checked {
            background: var(--primary);
        }
        
        .toggle-checkbox::before {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: left 0.2s;
        }
        
        .toggle-checkbox:checked::before {
            left: 22px;
        }
    </style>
</head>
<body>

    <header>
        <div>
            <small>HEART RATE</small>
            <div>
                <span id="bpmDisplay" style="font-size: 2em; font-family: monospace;">--</span>
                <span id="modeBadge" class="hidden"></span>
            </div>
        </div>
        <canvas id="previewCanvas" width="30" height="30" class="canvas-preview hidden"></canvas>
    </header>

    <div id="canvasContainer">
        <canvas id="ppgCanvas"></canvas>
        <video id="videoElement" playsinline></video>
        
        <div id="instructionOverlay" class="overlay">
            <div>
                <p><strong>Ready to Measure</strong></p>
                <p>Go to the Record tab to start.</p>
                <p><small><strong>Camera Mode:</strong> Cover the back camera & flash gently with your fingertip.</small></p>
            </div>
        </div>

        <div id="saturationWarning" class="warning hidden">
            <span>⚠️ SIGNAL CLIPPING - Move finger slightly</span>
        </div>
        
        <div id="torchWarning" class="warning hidden" style="top: 48px;">
            <span>⚠️ Camera flash unavailable - Ensure good lighting</span>
        </div>

        <div id="reviewControls" class="review-controls">
            <div>
                <span>Timeline</span>
                <span id="reviewTimeDisplay">Live</span>
            </div>
            <input type="range" id="historySlider" min="0" max="100" value="100" class="scrubber">
            <div class="btn-group">
                <button id="exportImgBtn">Save Graph Img</button>
                <button id="backToLiveBtn">Done</button>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="tabs">
            <button id="tabRecord" class="tab active">Record</button>
            <button id="tabHistory" class="tab">History</button>
            <button id="tabSettings" class="tab">Settings</button>
        </div>

        <div id="contentRecord" class="tab-content scroller">
            <div class="btn-group">
                <button id="cameraBtn">Camera</button>
                <button id="simulateBtn">Simulate</button>
                <button id="saveBtn">Save</button>
            </div>
            
            <div id="simControls" class="hidden">
                <label>Target BPM: <span id="targetBpmValue">75</span></label>
                <input type="range" id="bpmSlider" min="40" max="220" value="75">
            </div>
        </div>

        <div id="contentHistory" class="tab-content scroller hidden">
            <div style="padding: 12px; border-bottom: 1px solid #334155; background: rgba(30, 41, 59, 0.3); margin: -16px -16px 16px -16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 10px; font-weight: bold; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em;">Storage</span>
                    <span id="storageInfo" style="font-size: 10px; font-family: monospace; color: #64748b;">--</span>
                </div>
                <div style="width: 100%; background: #334155; border-radius: 9999px; height: 8px; overflow: hidden;">
                    <div id="storageBar" class="storage-bar" style="width: 0%"></div>
                </div>
            </div>

            <div style="padding: 8px 12px; background: rgba(30, 41, 59, 0.5); font-size: 10px; font-weight: bold; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.05em; display: flex; justify-content: space-between; align-items: center; margin: -16px -16px 12px -16px;">
                <span id="recordCount">0 Recordings</span>
                <div style="display: flex; gap: 8px;">
                    <button id="deleteOldestBtn" style="color: #f87171; padding: 4px; background: none; border: none; cursor: pointer; font-size: 10px;">Del Oldest</button>
                    <button id="exportJsonBtn" style="color: #38bdf8; padding: 4px; background: none; border: none; cursor: pointer; font-size: 10px;">Export All ⬇</button>
                </div>
            </div>

            <div id="savedList" class="recordings"></div>
            <div id="emptyState" class="hidden" style="text-align: center; color: #475569; padding: 48px 0;">
                <div style="margin-bottom: 8px;">No recordings yet</div>
                <div style="font-size: 12px; color: #334155;">Start recording in the Record tab</div>
            </div>
        </div>

        <div id="contentSettings" class="tab-content scroller">
            <div class="toggle-row">
                <label>Camera Preview</label>
                <input type="checkbox" id="settingPreview" class="toggle-checkbox">
            </div>
            
            <div class="setting-row">
                <label>
                    Auto-Stop (seconds)
                    <small>0 = Manual stop</small>
                </label>
                <input type="number" id="settingAutoStop" min="0" max="300" value="30">
            </div>
            
            <div class="setting-row">
                <label>
                    BPM Averaging (Beats)
                    <small>How many beats to average</small>
                </label>
                <input type="number" id="settingBpmWindow" min="2" max="50" value="4">
            </div>
            
            <div class="setting-row">
                <label>
                    Max Recordings
                    <small>0 = No limit (until full)</small>
                </label>
                <input type="number" id="settingMaxRecords" min="0" max="1000" value="20">
            </div>
            
            <div class="toggle-row">
                <label>Auto-Save on Stop</label>
                <input type="checkbox" id="settingAutoSave" class="toggle-checkbox">
            </div>
            
            <div class="camera-stats">
                <h4>Camera Specs</h4>
                <div id="cameraStats">
                    <div>Res: <span id="statRes">--</span></div>
                    <div>FPS: <span id="statFps">--</span></div>
                    <div>Exp: <span id="statExp">--</span></div>
                    <div>ISO: <span id="statIso">--</span></div>
                </div>
            </div>
            
            <div class="version">Pulse Monitor v2.7</div>
        </div>
    </div>

<script>
// ============================================================================
// CONSTANTS & CONFIG
// ============================================================================
const CONSTANTS = {
    VERSION: 4,
    
    SIGNAL: {
        WARMUP_FRAMES: 30,
        MAX_HISTORY_LENGTH: 10800,
        NORMALIZATION_WINDOW: 120,
        GAIN_SMOOTHING: 0.95,
        TARGET_GAIN_RANGE: 0.7,
        SIGNAL_CLAMP_MIN: -0.6,
        SIGNAL_CLAMP_MAX: 0.6,
        SATURATION_THRESHOLD: 250
    },
    
    BEAT_DETECTION: {
        MIN_GAP_SAMPLES: 15,
        MIN_AMPLITUDE: 0.15,
        DECAY_RATE: 0.99,
        THRESHOLD_MULTIPLIER: 0.5,
        BASE_THRESHOLD: 0.05,
        REFRACTORY_PERIOD_MS: 250,
        REFRACTORY_MIN_MS: 250,
        REFRACTORY_MAX_MS: 1000,
        REFRACTORY_FACTOR: 0.6
    },
    
    BPM: {
        DEFAULT_WINDOW: 8,
        SMOOTHING: 0.7,
        MS_PER_MINUTE: 60000
    },
    
    SIMULATION: {
        DEFAULT_BPM: 75,
        GAUSSIAN_P_WAVE: { amplitude: 0.3, center: 0.5, width: 0.12 },
        GAUSSIAN_QRS: { amplitude: 1.0, center: 0.2, width: 0.08 },
        NOISE_AMPLITUDE: 0.1,
        SIGNAL_SCALE: 0.05
    },
    
    STORAGE: {
        KEY: 'hr_records',
        SETTINGS_KEY: 'pulse_settings',
        QUOTA_CRITICAL: 0.95,
        MIN_SAVE_LENGTH: 60,
        DELETE_BATCH_SIZE: 10,
        MAX_STORAGE_MB: 5
    },
    
    CAMERA: {
        PREVIEW_SIZE: 30
    }
};

const Config = {
    showPreview: false,
    autoStopSeconds: 0,
    autoSave: false,
    bpmCalculationWindow: CONSTANTS.BPM.DEFAULT_WINDOW,
    maxRecords: 50,
    
    load() {
        const saved = localStorage.getItem(CONSTANTS.STORAGE.SETTINGS_KEY);
        if (saved) {
            try {
                Object.assign(this, JSON.parse(saved));
            } catch(e) {
                console.error('Failed to load settings', e);
            }
        }
    },
    
    save() {
        const data = {
            showPreview: this.showPreview,
            autoStopSeconds: this.autoStopSeconds,
            bpmCalculationWindow: this.bpmCalculationWindow,
            autoSave: this.autoSave,
            maxRecords: this.maxRecords
        };
        localStorage.setItem(CONSTANTS.STORAGE.SETTINGS_KEY, JSON.stringify(data));
    }
};

const DOM = {
    video: document.getElementById('videoElement'),
    ppgCanvas: document.getElementById('ppgCanvas'),
    previewCanvas: document.getElementById('previewCanvas'),
    bpmDisplay: document.getElementById('bpmDisplay'),
    modeBadge: document.getElementById('modeBadge'),
    saturationWarning: document.getElementById('saturationWarning'),
    torchWarning: document.getElementById('torchWarning'),
    instructionOverlay: document.getElementById('instructionOverlay'),
    reviewControls: document.getElementById('reviewControls'),
    reviewTimeDisplay: document.getElementById('reviewTimeDisplay'),
    historySlider: document.getElementById('historySlider'),
    
    tabRecord: document.getElementById('tabRecord'),
    tabHistory: document.getElementById('tabHistory'),
    tabSettings: document.getElementById('tabSettings'),
    contentRecord: document.getElementById('contentRecord'),
    contentHistory: document.getElementById('contentHistory'),
    contentSettings: document.getElementById('contentSettings'),
    
    cameraBtn: document.getElementById('cameraBtn'),
    simulateBtn: document.getElementById('simulateBtn'),
    saveBtn: document.getElementById('saveBtn'),
    backToLiveBtn: document.getElementById('backToLiveBtn'),
    exportImgBtn: document.getElementById('exportImgBtn'),
    exportJsonBtn: document.getElementById('exportJsonBtn'),
    deleteOldestBtn: document.getElementById('deleteOldestBtn'),
    
    simControls: document.getElementById('simControls'),
    bpmSlider: document.getElementById('bpmSlider'),
    targetBpmValue: document.getElementById('targetBpmValue'),
    savedList: document.getElementById('savedList'),
    
    settingPreview: document.getElementById('settingPreview'),
    settingAutoStop: document.getElementById('settingAutoStop'),
    settingAutoSave: document.getElementById('settingAutoSave'),
    settingBpmWindow: document.getElementById('settingBpmWindow'),
    settingMaxRecords: document.getElementById('settingMaxRecords'),
    
    statRes: document.getElementById('statRes'),
    statFps: document.getElementById('statFps'),
    statExp: document.getElementById('statExp'),
    statIso: document.getElementById('statIso'),
    
    storageInfo: document.getElementById('storageInfo'),
    storageBar: document.getElementById('storageBar'),
    recordCount: document.getElementById('recordCount'),
    emptyState: document.getElementById('emptyState')
};

const ppgCtx = DOM.ppgCanvas.getContext('2d', { alpha: false });
const previewCtx = DOM.previewCanvas.getContext('2d', { willReadFrequently: true });

let animationFrameId;

// ============================================================================
// APP STATE
// ============================================================================
const AppState = {
    mode: 'idle',
    totalTime: 0,
    lastTime: null,
    simPhase: 0,
    simBpm: CONSTANTS.SIMULATION.DEFAULT_BPM,
    history: [],
    reviewData: null,
    reviewOffset: 0,
    
    addHistoryPoint(time, val, threshold, isBeat, bpm) {
        this.history.push({ time, val, threshold, beat: isBeat, bpm });
        if (this.history.length > DOM.ppgCanvas.width * 2) {
            this.history.shift();
        }
    },
    
    clearHistory() {
        this.history = [];
        this.totalTime = 0;
        this.lastTime = null;
    }
};

// ============================================================================
// CAMERA MODULE
// ============================================================================
const Camera = {
    stream: null,
    torchSupported: false,
    
    async start() {
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 }
                }
            });
            
            DOM.video.srcObject = this.stream;
            await DOM.video.play();
            
            const track = this.stream.getVideoTracks()[0];
            const capabilities = track.getCapabilities?.() || {};
            this.torchSupported = capabilities.torch === true;
            
            if (this.torchSupported) {
                await track.applyConstraints({ advanced: [{ torch: true }] });
                DOM.torchWarning.classList.add('hidden');
            } else {
                DOM.torchWarning.classList.remove('hidden');
            }
            
            return true;
        } catch (err) {
            console.error('Camera error:', err);
            alert('Camera access failed: ' + err.message);
            return false;
        }
    },
    
    getStats(track) {
        const s = track.getSettings();
        return {
            resolution: `${s.width}x${s.height}`,
            fps: s.frameRate ? s.frameRate.toFixed(1) : '--',
            exposure: s.exposureCompensation || s.exposureMode || '--',
            iso: s.iso || '--'
        };
    },
    
    stop() {
        if (this.stream) {
            this.stream.getTracks().forEach(t => t.stop());
            this.stream = null;
        }
        DOM.video.srcObject = null;
    }
};

// ============================================================================
// WAKE LOCK
// ============================================================================
const WakeLock = {
    lock: null,
    
    async acquire() {
        if ('wakeLock' in navigator && !this.lock) {
            try {
                this.lock = await navigator.wakeLock.request('screen');
                this.lock.addEventListener('release', () => { this.lock = null; });
                return true;
            } catch (err) {
                console.warn('Wake Lock error', err);
            }
        }
        return false;
    },
    
    async release() {
        if (this.lock) {
            try { await this.lock.release(); } 
            catch(e) { console.warn('Wake Lock release error', e); }
            this.lock = null;
        }
    }
};

// ============================================================================
// SIGNAL PROCESSING
// ============================================================================
const SignalProcessor = {
    recentValues: [],
    currentGain: 1.0,
    signalMean: 0,
    framesSinceStart: 0,
    
    reset() {
        this.recentValues = [];
        this.currentGain = 1.0;
        this.signalMean = 0;
        this.framesSinceStart = 0;
    },
    
    normalize(val) {
        this.recentValues.push(val);
        if (this.recentValues.length > CONSTANTS.SIGNAL.NORMALIZATION_WINDOW) {
            this.recentValues.shift();
        }
        
        let min = -0.01, max = 0.01;
        for (let v of this.recentValues) {
            if (v < min) min = v;
            if (v > max) max = v;
        }
        
        const targetGain = CONSTANTS.SIGNAL.TARGET_GAIN_RANGE / ((max - min) || 0.1);
        this.currentGain = (this.currentGain * CONSTANTS.SIGNAL.GAIN_SMOOTHING) + 
                          (targetGain * (1 - CONSTANTS.SIGNAL.GAIN_SMOOTHING));
        
        const normalized = val * this.currentGain;
        return Math.max(CONSTANTS.SIGNAL.SIGNAL_CLAMP_MIN, 
                       Math.min(CONSTANTS.SIGNAL.SIGNAL_CLAMP_MAX, normalized));
    },
    
    processFrame(videoElement, offscreenContext) {
        const size = CONSTANTS.CAMERA.PREVIEW_SIZE;
        offscreenContext.drawImage(videoElement, 0, 0, size, size);
        const data = offscreenContext.getImageData(0, 0, size, size).data;
        
        let sum = 0, count = 0;
        for (let i = 0; i < data.length; i += 16) {
            sum += data[i + 1];
            count++;
        }
        
        const avg = sum / count;
        const isSaturated = avg > CONSTANTS.SIGNAL.SATURATION_THRESHOLD;
        
        if (this.framesSinceStart < CONSTANTS.SIGNAL.WARMUP_FRAMES) {
            this.signalMean = avg;
            this.framesSinceStart++;
            return { signal: 0, isSaturated };
        }
        
        this.signalMean = (this.signalMean * 0.95) + (avg * 0.05);
        return { signal: this.normalize(this.signalMean - avg), isSaturated };
    },
    
    generateSimulation(phase, bpm, totalTime) {
        const duration = 60 / bpm;
        const t = (phase % duration) / duration;
        
        const gaussian = (params) => {
            const { amplitude, center, width } = params;
            return amplitude * Math.exp(-Math.pow(t - center, 2) / (2 * width * width));
        };
        
        const signal = 
            gaussian(CONSTANTS.SIMULATION.GAUSSIAN_QRS) + 
            gaussian(CONSTANTS.SIMULATION.GAUSSIAN_P_WAVE) + 
            Math.sin(totalTime) * CONSTANTS.SIMULATION.NOISE_AMPLITUDE;
        
        return this.normalize(signal * CONSTANTS.SIMULATION.SIGNAL_SCALE);
    }
};

// ============================================================================
// BEAT DETECTION
// ============================================================================
const BeatDetector = {
    lastBeatTime: 0,
    refractoryPeriod: CONSTANTS.BEAT_DETECTION.REFRACTORY_PERIOD_MS,
    runningMax: 0.1,
    threshold: CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD,
    detectedBeats: [],
    bpm: 0,
    
    reset() {
        this.lastBeatTime = 0;
        this.refractoryPeriod = CONSTANTS.BEAT_DETECTION.REFRACTORY_PERIOD_MS;
        this.runningMax = 0.1;
        this.threshold = CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD;
        this.detectedBeats = [];
        this.bpm = 0;
    },
    
    process(signal, timestamp, bpmWindow) {
        this.runningMax *= CONSTANTS.BEAT_DETECTION.DECAY_RATE;
        this.threshold = Math.max(
            this.runningMax * CONSTANTS.BEAT_DETECTION.THRESHOLD_MULTIPLIER,
            CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD
        );
        
        if (signal > this.runningMax) this.runningMax = signal;
        
        let isBeat = false;
        
        if (signal > this.threshold && 
            (timestamp - this.lastBeatTime) > this.refractoryPeriod &&
            this.runningMax > CONSTANTS.BEAT_DETECTION.MIN_AMPLITUDE) {
            
            this.lastBeatTime = timestamp;
            isBeat = true;
            this.detectedBeats.push(timestamp);
            
            while(this.detectedBeats.length > bpmWindow) {
                this.detectedBeats.shift();
            }

            if (this.detectedBeats.length >= 2) {
                let sum = 0;
                for (let i = 1; i < this.detectedBeats.length; i++) {
                    sum += (this.detectedBeats[i] - this.detectedBeats[i-1]);
                }
                
                const avgInterval = sum / (this.detectedBeats.length - 1);
                const newBpm = CONSTANTS.BPM.MS_PER_MINUTE / avgInterval;
                
                this.bpm = this.bpm === 0 ? newBpm : 
                    (this.bpm * CONSTANTS.BPM.SMOOTHING + newBpm * (1 - CONSTANTS.BPM.SMOOTHING));
                
                this.refractoryPeriod = Math.max(
                    CONSTANTS.BEAT_DETECTION.REFRACTORY_MIN_MS,
                    Math.min(
                        (CONSTANTS.BPM.MS_PER_MINUTE / this.bpm) * CONSTANTS.BEAT_DETECTION.REFRACTORY_FACTOR,
                        CONSTANTS.BEAT_DETECTION.REFRACTORY_MAX_MS
                    )
                );
            }
        }
        
        return { isBeat, threshold: this.threshold, bpm: Math.round(this.bpm) };
    },
    
    calculateThreshold(samples) {
        let runningMax = 0.1;
        const results = [];
        
        samples.forEach(val => {
            runningMax *= CONSTANTS.BEAT_DETECTION.DECAY_RATE;
            if (val > runningMax) runningMax = val;
            
            const threshold = Math.max(
                runningMax * CONSTANTS.BEAT_DETECTION.THRESHOLD_MULTIPLIER,
                CONSTANTS.BEAT_DETECTION.BASE_THRESHOLD
            );
            results.push({ threshold, runningMax });
        });
        
        return results;
    },
    
    detectBeats(samples, thresholds) {
        const beatIndices = [];
        let lastBeatIndex = -1000;
        
        samples.forEach((val, i) => {
            const { threshold, runningMax } = thresholds[i];
            
            if (val > threshold && 
                (i - lastBeatIndex) > CONSTANTS.BEAT_DETECTION.MIN_GAP_SAMPLES && 
                runningMax > CONSTANTS.BEAT_DETECTION.MIN_AMPLITUDE) {
                beatIndices.push(i);
                lastBeatIndex = i;
            }
        });
        
        return beatIndices;
    },
    
    calculateBPM(beatIndices, timestamps, windowSize) {
        if (beatIndices.length < 2 || !timestamps) return null;
        
        const recent = beatIndices.slice(-windowSize);
        if (recent.length < 2) return null;
        
        const timeSpan = timestamps[recent[recent.length - 1]] - timestamps[recent[0]];
        if (timeSpan <= 0) return null;
        
        return Math.round(60 * (recent.length - 1) / timeSpan);
    }
};

// ============================================================================
// RENDERER
// ============================================================================
const Renderer = {
    drawSignal(canvas, ppgCtx, data, mode, viewStart, viewEnd) {
        if (!data || !data.length) return;
        
        const viewData = data.slice(viewStart, viewEnd);
        if (!viewData.length) return;

        const cy = canvas.height / 2;
        const sy = canvas.height / 2.2;
        const color = mode === 'simulate' ? '#a855f7' : (mode === 'review' ? '#f59e0b' : '#ef4444');
        
        ppgCtx.textAlign = "center";
        ppgCtx.textBaseline = "bottom";
        ppgCtx.font = "9px monospace";
        
        const signalPath = [];
        const thresholdPath = [];
        const beatMarkers = [];
        
        for (let i = 0; i < viewData.length; i++) {
            const d = viewData[i];
            const y = cy - d.val * sy;
            
            signalPath.push({ x: i, y });
            thresholdPath.push({ x: i, y: cy - d.threshold * sy });
            
            if (d.beat) beatMarkers.push({ x: i, y });
            
            if (i > 0) {
                const prevTime = viewData[i - 1].time;
                if (Math.floor(d.time) !== Math.floor(prevTime)) {
                    ppgCtx.beginPath();
                    ppgCtx.strokeStyle = 'rgba(255,255,255,0.15)';
                    ppgCtx.moveTo(i, 0);
                    ppgCtx.lineTo(i, canvas.height);
                    ppgCtx.stroke();
                    
                    ppgCtx.fillStyle = 'rgba(255,255,255,0.3)';
                    ppgCtx.fillText(Math.floor(d.time) + 's', i, canvas.height - 2);
                }
            }
        }
        
        ppgCtx.beginPath();
        ppgCtx.strokeStyle = 'rgba(255,200,0,0.3)';
        ppgCtx.setLineDash([4, 4]);
        thresholdPath.forEach((p, i) => {
            i === 0 ? ppgCtx.moveTo(p.x, p.y) : ppgCtx.lineTo(p.x, p.y);
        });
        ppgCtx.stroke();
        ppgCtx.setLineDash([]);
        
        ppgCtx.beginPath();
        ppgCtx.strokeStyle = color;
        ppgCtx.lineWidth = 2;
        signalPath.forEach((p, i) => {
            i === 0 ? ppgCtx.moveTo(p.x, p.y) : ppgCtx.lineTo(p.x, p.y);
        });
        ppgCtx.stroke();
        
        ppgCtx.lineTo(viewData.length - 1, canvas.height);
        ppgCtx.lineTo(0, canvas.height);
        ppgCtx.fillStyle = color + "20";
        ppgCtx.fill();
        
        ppgCtx.fillStyle = "#fff";
        beatMarkers.forEach(p => {
            ppgCtx.beginPath();
            ppgCtx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ppgCtx.fill();
        });
    }
};

// ============================================================================
// STORAGE
// ============================================================================
const Storage = {
    async save(recording) {
        const records = this.loadAll();
        
        if (Config.maxRecords > 0 && records.length >= Config.maxRecords) {
            records.splice(Config.maxRecords - 1);
        }

        const existingIndex = records.findIndex(r => r.id === recording.id);
        if (existingIndex >= 0) {
            records[existingIndex] = recording;
        } else {
            records.unshift(recording);
        }

        localStorage.setItem(CONSTANTS.STORAGE.KEY, JSON.stringify(records));
    },
    
    loadAll() {
        const raw = localStorage.getItem(CONSTANTS.STORAGE.KEY);
        if (!raw) return [];
        
        try {
            const records = JSON.parse(raw);
            return records.filter(r => r.v === CONSTANTS.VERSION && Array.isArray(r.samples));
        } catch(e) {
            console.error('Failed to load records', e);
            return [];
        }
    },
    
    delete(id) {
        const records = this.loadAll();
        localStorage.setItem(CONSTANTS.STORAGE.KEY, 
            JSON.stringify(records.filter(r => r.id !== id)));
    },
    
    deleteOldest(count = CONSTANTS.STORAGE.DELETE_BATCH_SIZE) {
        const records = this.loadAll();
        if (records.length === 0) return 0;
        
        const toDelete = Math.min(count, records.length);
        records.splice(records.length - toDelete, toDelete);
        localStorage.setItem(CONSTANTS.STORAGE.KEY, JSON.stringify(records));
        return toDelete;
    },
    
    exportAll() {
        const raw = localStorage.getItem(CONSTANTS.STORAGE.KEY);
        if (!raw) return null;
        return URL.createObjectURL(new Blob([raw], { type: 'application/json' }));
    },
    
    async checkQuota() {
        if (!navigator.storage || !navigator.storage.estimate) return true;
        
        try {
            const estimate = await navigator.storage.estimate();
            if (estimate.quota > 0) {
                const usageRatio = estimate.usage / estimate.quota;
                if (usageRatio > CONSTANTS.STORAGE.QUOTA_CRITICAL) {
                    alert("Storage full. Delete old recordings to continue.");
                    return false;
                }
            }
        } catch(e) {
            console.warn('Quota check failed', e);
        }
        return true;
    },
    
    getStorageSize() {
        const records = this.loadAll();
        return new Blob([JSON.stringify(records)]).size;
    }
};

// ============================================================================
// UI HELPERS
// ============================================================================
const UI = {
    switchTab(tab) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
        
        if (tab === 'record') {
            DOM.tabRecord.classList.add('active');
            DOM.contentRecord.classList.remove('hidden');
        } else if (tab === 'history') {
            DOM.tabHistory.classList.add('active');
            DOM.contentHistory.classList.remove('hidden');
            renderRecordingsList();
        } else if (tab === 'settings') {
            DOM.tabSettings.classList.add('active');
            DOM.contentSettings.classList.remove('hidden');
        }
    },
    
    updateBPMDisplay(bpm, colorClass) {
        DOM.bpmDisplay.innerText = bpm > 0 ? bpm : '--';
        DOM.bpmDisplay.className = colorClass || '';
    },
    
    updateStorageInfo() {
        const records = Storage.loadAll();
        const sizeMB = (Storage.getStorageSize() / 1024 / 1024).toFixed(2);
        const percentage = (parseFloat(sizeMB) / CONSTANTS.STORAGE.MAX_STORAGE_MB) * 100;
        
        DOM.storageInfo.innerText = `${sizeMB}MB / ${CONSTANTS.STORAGE.MAX_STORAGE_MB}MB`;
        DOM.storageBar.style.width = Math.min(percentage, 100) + '%';
        DOM.recordCount.innerText = `${records.length} Recording${records.length !== 1 ? 's' : ''}`;
        
        const barClass = percentage > 90 ? 'storage-bar critical' : 
            (percentage > 70 ? 'storage-bar warning' : 'storage-bar');
        DOM.storageBar.className = barClass;
    },
    
    updateCameraStats(track) {
        const stats = Camera.getStats(track);
        DOM.statRes.innerText = stats.resolution;
        DOM.statFps.innerText = stats.fps;
        DOM.statExp.innerText = stats.exposure;
        DOM.statIso.innerText = stats.iso;
    },
    
    updateButtonsForMode(mode) {
        DOM.cameraBtn.innerText = mode === 'camera' ? 'Stop' : 'Camera';
        DOM.simulateBtn.innerText = mode === 'simulate' ? 'Stop' : 'Simulate';
        DOM.saveBtn.disabled = mode !== 'idle' || AppState.history.length === 0;
    }
};

// ============================================================================
// MODE MANAGEMENT
// ============================================================================
async function setMode(newMode) {
    if (AppState.mode === newMode) return;
    
    // AUTO-SAVE CHECK when stopping recording
    if ((AppState.mode === 'camera' || AppState.mode === 'simulate') && newMode === 'idle') {
        if (Config.autoSave && AppState.history.length > 0) {
            saveRecording();
        }
    }
    
    if (AppState.mode === 'camera') {
        Camera.stop();
        await WakeLock.release();
    }
    
    AppState.mode = newMode;
    
    if (newMode === 'idle') {
        DOM.instructionOverlay.classList.remove('hidden');
        DOM.modeBadge.classList.add('hidden');
        DOM.reviewControls.classList.remove('active');
        DOM.saturationWarning.classList.add('hidden');
        DOM.torchWarning.classList.add('hidden');
        DOM.simControls.classList.add('hidden');
        UI.updateBPMDisplay(0);
        
    } else if (newMode === 'camera') {
        const started = await Camera.start();
        if (!started) {
            AppState.mode = 'idle';
            return;
        }
        await WakeLock.acquire();
        AppState.clearHistory();
        SignalProcessor.reset();
        BeatDetector.reset();
        DOM.instructionOverlay.classList.add('hidden');
        DOM.modeBadge.classList.remove('hidden');
        DOM.modeBadge.innerText = 'CAMERA';
        DOM.simControls.classList.add('hidden');
        
        const track = Camera.stream.getVideoTracks()[0];
        UI.updateCameraStats(track);
        
    } else if (newMode === 'simulate') {
        AppState.clearHistory();
        AppState.simPhase = 0;
        SignalProcessor.reset();
        BeatDetector.reset();
        DOM.instructionOverlay.classList.add('hidden');
        DOM.modeBadge.classList.remove('hidden');
        DOM.modeBadge.innerText = 'SIMULATE';
        DOM.simControls.classList.remove('hidden');
        
    } else if (newMode === 'review') {
        DOM.instructionOverlay.classList.add('hidden');
        DOM.reviewControls.classList.add('active');
        DOM.modeBadge.classList.remove('hidden');
        DOM.modeBadge.innerText = 'REVIEW';
        DOM.simControls.classList.add('hidden');
    }
    
    UI.updateButtonsForMode(newMode);
}

// ============================================================================
// ACTIONS
// ============================================================================
async function saveRecording() {
    if (AppState.history.length === 0) return;
    
    if (AppState.history.length < CONSTANTS.STORAGE.MIN_SAVE_LENGTH) {
        if (!Config.autoSave) {
            alert("Too short to save (minimum 1 second)");
        }
        return;
    }

    if (!(await Storage.checkQuota())) return;
    
    const recording = {
        id: Date.now(),
        v: CONSTANTS.VERSION,
        timestamp: new Date().toISOString(),
        duration: AppState.totalTime,
        avgBpm: Math.round(BeatDetector.bpm) || 0,
        samples: AppState.history.map(h => ({ t: h.time, v: h.val }))
    };
    
    await Storage.save(recording);
    renderRecordingsList();
    
    if (!Config.autoSave) {
        alert(`Saved! BPM: ${recording.avgBpm || 'N/A'}, Duration: ${AppState.totalTime.toFixed(1)}s`);
    }
}

function exportGraphImage() {
    DOM.ppgCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `pulse-graph-${Date.now()}.png`;
        a.click();
        URL.revokeObjectURL(url);
    });
}

function exportAllData() {
    const url = Storage.exportAll();
    if (!url) return alert("No data to export");
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `heart_rate_data_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function saveSettings() {
    Config.showPreview = DOM.settingPreview.checked;
    Config.autoStopSeconds = parseInt(DOM.settingAutoStop.value) || 0;
    Config.bpmCalculationWindow = parseInt(DOM.settingBpmWindow.value) || CONSTANTS.BPM.DEFAULT_WINDOW;
    Config.maxRecords = parseInt(DOM.settingMaxRecords.value) || 0;
    Config.autoSave = DOM.settingAutoSave.checked;
    
    Config.save();
    DOM.previewCanvas.classList.toggle('hidden', !Config.showPreview);
    BeatDetector.reset();
}

function loadSettings() {
    Config.load();
    DOM.settingPreview.checked = Config.showPreview;
    DOM.settingAutoStop.value = Config.autoStopSeconds;
    DOM.settingAutoSave.checked = Config.autoSave;
    DOM.settingBpmWindow.value = Config.bpmCalculationWindow;
    DOM.settingMaxRecords.value = Config.maxRecords;
    DOM.previewCanvas.classList.toggle('hidden', !Config.showPreview);
}

// ============================================================================
// RECORDINGS LIST
// ============================================================================
function renderRecordingsList() {
    const records = Storage.loadAll();
    UI.updateStorageInfo();
    DOM.savedList.innerHTML = '';
    
    if (!records.length) {
        DOM.emptyState.classList.remove('hidden');
        return;
    }
    
    DOM.emptyState.classList.add('hidden');
    
    records.forEach(r => {
        const d = new Date(r.timestamp);
        const div = document.createElement('div');
        div.className = 'recording-item';
        
        div.innerHTML = `
            <div>
                <div style="font-weight: bold; color: #38bdf8; font-size: 12px;">
                    ${d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                </div>
                <div style="font-size: 10px; color: #64748b;">
                    ${d.toLocaleDateString()} • ${r.duration.toFixed(1)}s
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 12px;">
                <div style="text-align: right;">
                    <div style="font-size: 9px; color: #64748b; text-transform: uppercase;">Avg BPM</div>
                    <div style="font-weight: bold; color: #e2e8f0; font-size: 14px;">${r.avgBpm}</div>
                </div>
                <button class="delete-btn del" data-id="${r.id}">✕</button>
            </div>
        `;
        
        div.onclick = (e) => {
            if (e.target.classList.contains('del')) {
                if (confirm('Delete this recording?')) {
                    Storage.delete(r.id);
                    renderRecordingsList();
                }
            } else {
                openReview(r);
            }
        };
        
        DOM.savedList.appendChild(div);
    });
}

function openReview(recording) {
    setMode('review');
    
    const values = recording.samples.map(s => s.v);
    const timestamps = recording.samples.map(s => s.t);
    
    const thresholds = BeatDetector.calculateThreshold(values);
    const beatIndices = BeatDetector.detectBeats(values, thresholds);
    const calculatedBpm = BeatDetector.calculateBPM(beatIndices, timestamps, Config.bpmCalculationWindow);

    AppState.reviewData = recording.samples.map((sample, i) => ({
        time: sample.t,
        val: sample.v,
        threshold: thresholds[i].threshold,
        beat: beatIndices.includes(i),
        bpm: calculatedBpm || recording.avgBpm
    }));
    
    AppState.reviewData.duration = recording.duration;
    
    DOM.historySlider.min = 0;
    DOM.historySlider.max = recording.samples.length;
    DOM.historySlider.value = recording.samples.length;
    AppState.reviewOffset = recording.samples.length;
    
    UI.updateBPMDisplay(calculatedBpm || recording.avgBpm);
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================
async function loop(timestamp) {
    if (!AppState.lastTime) AppState.lastTime = timestamp;
    
    const dt = (timestamp - AppState.lastTime) / 1000;
    AppState.lastTime = timestamp;

    if (AppState.mode === 'camera' || AppState.mode === 'simulate') {
        AppState.totalTime += dt;
        
        if (Config.autoStopSeconds > 0 && AppState.totalTime >= Config.autoStopSeconds) {
            await setMode('idle');
        } else {
            let signal, isSaturated;
            
            if (AppState.mode === 'camera') {
                const result = SignalProcessor.processFrame(DOM.video, previewCtx);
                signal = result.signal;
                isSaturated = result.isSaturated;
                DOM.saturationWarning.classList.toggle('hidden', !isSaturated);
            } else {
                AppState.simPhase += dt;
                signal = SignalProcessor.generateSimulation(AppState.simPhase, AppState.simBpm, AppState.totalTime);
            }
            
            const result = BeatDetector.process(signal, timestamp, Config.bpmCalculationWindow);
            
            if (result.bpm > 0) {
                UI.updateBPMDisplay(result.bpm);
            }
            
            AppState.addHistoryPoint(AppState.totalTime, signal, result.threshold, result.isBeat, result.bpm);
        }
    }
    
    const data = AppState.mode === 'review' ? AppState.reviewData : AppState.history;
    if (data && data.length > 0) {
        const end = AppState.mode === 'review' ? AppState.reviewOffset : data.length;
        const start = Math.max(0, end - DOM.ppgCanvas.width);
        
        ppgCtx.fillStyle = '#0f172a';
        ppgCtx.fillRect(0, 0, DOM.ppgCanvas.width, DOM.ppgCanvas.height);
        Renderer.drawSignal(DOM.ppgCanvas, ppgCtx, data, AppState.mode, start, end);
        
        if (AppState.mode === 'review' && end > 0 && data[end - 1]) {
            const currentTime = data[end - 1].time;
            const totalTime = data[data.length - 1].time;
            DOM.reviewTimeDisplay.innerText = `-${(totalTime - currentTime).toFixed(1)}s`;
            
            const recentBeats = [];
            for (let i = end - 1; i >= 0 && recentBeats.length < Config.bpmCalculationWindow; i--) {
                if (data[i].beat) {
                    recentBeats.push(data[i].time);
                }
            }
            
            if (recentBeats.length >= 2) {
                const timeSpan = recentBeats[0] - recentBeats[recentBeats.length - 1];
                const displayBpm = Math.round(60 * (recentBeats.length - 1) / timeSpan);
                UI.updateBPMDisplay(displayBpm);
            }
        }
    }
    
    animationFrameId = requestAnimationFrame(loop);
}

// ============================================================================
// EVENT LISTENERS
// ============================================================================
DOM.tabRecord.onclick = () => UI.switchTab('record');
DOM.tabHistory.onclick = () => UI.switchTab('history');
DOM.tabSettings.onclick = () => UI.switchTab('settings');

DOM.historySlider.oninput = e => AppState.reviewOffset = parseInt(e.target.value);
DOM.bpmSlider.oninput = e => {
    AppState.simBpm = parseInt(e.target.value);
    DOM.targetBpmValue.innerText = AppState.simBpm;
};

DOM.cameraBtn.onclick = () => setMode(AppState.mode === 'camera' ? 'idle' : 'camera');
DOM.simulateBtn.onclick = () => setMode(AppState.mode === 'simulate' ? 'idle' : 'simulate');
DOM.saveBtn.onclick = saveRecording;
DOM.backToLiveBtn.onclick = () => setMode('idle');
DOM.exportImgBtn.onclick = exportGraphImage;
DOM.exportJsonBtn.onclick = exportAllData;

DOM.deleteOldestBtn.onclick = () => {
    const records = Storage.loadAll();
    if (records.length === 0) return alert("No records to delete");
    
    const toDelete = Math.min(CONSTANTS.STORAGE.DELETE_BATCH_SIZE, records.length);
    if (confirm(`Delete oldest ${toDelete} recording${toDelete > 1 ? 's' : ''}?`)) {
        Storage.deleteOldest();
        renderRecordingsList();
    }
};

DOM.settingPreview.onchange = saveSettings;
DOM.settingAutoStop.oninput = saveSettings;
DOM.settingAutoSave.onchange = saveSettings;
DOM.settingBpmWindow.oninput = saveSettings;
DOM.settingMaxRecords.oninput = saveSettings;

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        cancelAnimationFrame(animationFrameId);
        if (AppState.mode === 'camera') {
            Camera.stop();
            WakeLock.release();
            AppState.mode = 'idle';
            DOM.modeBadge.innerText = "PAUSED";
            DOM.saveBtn.disabled = false;
            DOM.saveBtn.innerText = "Save Partial";
            UI.updateButtonsForMode('idle');
        }
    } else {
        loop(performance.now());
    }
});

window.onpagehide = () => {
    Camera.stop();
    WakeLock.release();
};

// ============================================================================
// CANVAS RESIZE
// ============================================================================
function resizeCanvas() {
    const container = DOM.ppgCanvas.parentElement;
    DOM.ppgCanvas.width = container.clientWidth;
    DOM.ppgCanvas.height = container.clientHeight;
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ============================================================================
// INITIALIZATION
// ============================================================================
loadSettings();
renderRecordingsList();
UI.switchTab('record');
loop(performance.now());

</script>
</body>
</html>
